#include <iostream>
#include <cmath>

// Calculates (base^exponent) % modulus efficiently
int modPow(int base, int exponent, int modulus) {
    if (modulus == 1)
        return 0;

    int result = 1;
    base = base % modulus;

    while (exponent > 0) {
        if (exponent % 2 == 1)
            result = (result * base) % modulus;

        exponent = exponent >> 1;
        base = (base * base) % modulus;
    }

    return result;
}

// Function to check if a number is prime
bool isPrime(int number) {
    if (number <= 1)
        return false;

    for (int i = 2; i <= sqrt(number); ++i) {
        if (number % i == 0)
            return false;
    }

    return true;
}

// Function to calculate the greatest common divisor (GCD)
int gcd(int a, int b) {
    if (b == 0)
        return a;

    return gcd(b, a % b);
}

// Function to calculate modular multiplicative inverse
int modInverse(int a, int m) {
    a = a % m;

    for (int x = 1; x < m; ++x) {
        if ((a * x) % m == 1)
            return x;
    }

    return -1; // Error: Modular inverse does not exist
}

// Function to encrypt a message using RSA algorithm
int encrypt(int message, int publicKey, int modulus) {
    return modPow(message, publicKey, modulus);
}

// Function to decrypt a ciphertext using RSA algorithm
int decrypt(int ciphertext, int privateKey, int modulus) {
    return modPow(ciphertext, privateKey, modulus);
}

int main() {
    int p, q; // Prime numbers
    int n, phi; // Modulus and Euler's totient function
    int e, d; // Public and private keys
    int message, encrypted, decrypted;

    // Step 1: Choose two prime numbers
    do {
        std::cout << "Enter a prime number (p): ";
        std::cin >> p;
    } while (!isPrime(p));

    do {
        std::cout << "Enter another prime number (q): ";
        std::cin >> q;
    } while (!isPrime(q));

    // Step 2: Compute modulus and Euler's totient function
    n = p * q;
    phi = (p - 1) * (q - 1);

    // Step 3: Choose a public key
    do {
        std::cout << "Enter a public key (e) such that 1 < e < " << phi << " and gcd(e, " << phi << ") = 1: ";
        std::cin >> e;
    } while (e <= 1 || e >= phi || gcd(e, phi) != 1);

    // Step 4: Compute private key
    d = modInverse(e, phi);

    // Step 5: Encryption and Decryption
    std::cout << "Enter a message to encrypt: ";
    std::cin >> message;

    encrypted = encrypt(message, e, n);
    decrypted = decrypt(encrypted, d, n);

    std::cout << "Encrypted message: " << encrypted << std::endl;
    std::cout << "Decrypted message: " << decrypted << std::endl;

    return 0;
}
