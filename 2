#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
using namespace std;
string generateKeyTable(const string& keyword) {
    string keyTable;
    for (char ch : keyword) {
        ch = toupper(ch);
        if (ch >= 'A' && ch <= 'Z' && keyTable.find(ch) == string::npos) {
            keyTable.push_back(ch);
        }
    }
    for (char ch = 'A'; ch <= 'Z'; ++ch) {
        if (ch != 'J' && keyTable.find(ch) == string::npos) {
            keyTable.push_back(ch);
        }
    }
    return keyTable;
}
string removeDuplicateLetters(const string& plaintext) {
    string processedText;
    char prev = '\0';
    for (char ch : plaintext) {
        ch = toupper(ch);
        if (ch >= 'A' && ch <= 'Z' && ch != 'J' && ch != prev) {
            processedText.push_back(ch);
            prev = ch;
        }
    }
    return processedText;
}
string preparePlaintext(const string& plaintext) {
    string preparedText;
    char prev = '\0';
    for (char ch : plaintext) {
        ch = toupper(ch);
        if (ch >= 'A' && ch <= 'Z' && ch != 'J') {
            if (ch == prev) {
                preparedText.push_back('X');
            }
            preparedText.push_back(ch);
            prev = ch;
        }
    }
    if (preparedText.length() % 2 != 0) {
        preparedText.push_back('X');
    }
    return preparedText;
}
void findPosition(const string& keyTable, char ch, int& row, int& col) {
    int index = keyTable.find(ch);
    row = index / 5;
    col = index % 5;
}
string encryptPlayfair(const string & plaintext, const string& keyTable) {
    string ciphertext;
    int row1, col1, row2, col2;
    for (size_t i = 0; i < plaintext.length(); i += 2) {
        char ch1 = plaintext[i];
        char ch2 = plaintext[i + 1];
        findPosition(keyTable, ch1, row1, col1);
        findPosition(keyTable, ch2, row2, col2);
        if (row1 == row2) {
            ciphertext.push_back(keyTable[row1 * 5 + (col1 + 1) % 5]);
            ciphertext.push_back(keyTable[row2 * 5 + (col2 + 1) % 5]);
        } else if (col1 == col2) {
            ciphertext.push_back(keyTable[((row1 + 1) % 5) * 5 + col1]);
            ciphertext.push_back(keyTable[((row2 + 1) % 5) * 5 + col2]);
        } else {
            ciphertext.push_back(keyTable[row1 * 5 + col2]);
            ciphertext.push_back(keyTable[row2 * 5 + col1]);
        }
    }
    return ciphertext;
}
string decryptPlayfair(const string& ciphertext, const string& keyTable) {
    string plaintext;
    int row1, col1, row2, col2;
    for (size_t i = 0; i < ciphertext.length(); i += 2) {
        char ch1 = ciphertext[i];
        char ch2 = ciphertext[i + 1];
        findPosition(keyTable, ch1, row1, col1);
        findPosition(keyTable, ch2, row2, col2);
        if (row1 == row2) {
            plaintext.push_back(keyTable[row1 * 5 + (col1 + 4) % 5]);
            plaintext.push_back(keyTable[row2 * 5 + (col2 + 4) % 5]);
        } else if (col1 == col2) {
            plaintext.push_back(keyTable[((row1 + 4) % 5) * 5 + col1]);
            plaintext.push_back(keyTable[((row2 + 4) % 5) * 5 + col2]);
        } else {
            plaintext.push_back(keyTable[row1 * 5 + col2]);
            plaintext.push_back(keyTable[row2 * 5 + col1]);
        }
    }
    return plaintext;
}
int main() {
    string keyword;
    string plaintext;
    cout << "Enter keyword: ";
    getline(cin, keyword);
    cout << "Enter plaintext: ";
    getline(cin, plaintext);
    string keyTable = generateKeyTable(keyword);
    string processedText = removeDuplicateLetters(plaintext);
    string preparedText = preparePlaintext(processedText);
    string ciphertext = encryptPlayfair(preparedText, keyTable);
    cout << "Ciphertext: " << ciphertext << endl;
    string decryptedText = decryptPlayfair(ciphertext, keyTable);
    cout << "Decrypted text: " << decryptedText << endl;
    return 0;
}
