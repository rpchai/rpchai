tree = [[[5, 1, 2], [8, -8, -9]], [[9, 4, 5], [-3, 4, 3]]]
root = 0
pruned = 0

def children(branch, depth, alpha, beta):
    global tree
    global root
    global pruned
    i = 0
    for child in branch:
        if type(child) is list:
            (nalpha, nbeta) = children(child, depth + 1, alpha, beta)
            if depth % 2 == 1:
                beta = nalpha if nalpha < beta else beta
            else:
                alpha = nbeta if nbeta > alpha else alpha
            branch[i] = alpha if depth % 2 == 0 else beta
            i += 1
        else:
            if depth % 2 == 0 and alpha < child:
                alpha = child
            if depth % 2 == 1 and beta > child:
                beta = child
            if alpha >= beta:
                pruned += 1
                break
    if depth == root:
        tree = alpha if root == 0 else beta
    return (alpha, beta)

def alpha_beta(in_tree=tree, start=root, up=-15, low=15):
    global tree
    global pruned
    global root
    (alpha, beta) = children(tree, start, up, low)
    return (alpha, beta, tree, pruned)
    

if __name__ == "__main__":
    res=[]
    (alpha, beta, tree, pruned)=alpha_beta(None)
    
    print ("(alpha, beta): ", alpha, beta)
    print ("Result: ", tree)
    print ("Times pruned: ", pruned)



import os
 
turn = 'X'
win = False
spaces = 9
 
def draw(board):
    for i in range(6, -1, -3):
        print(' ' + board[i] + '|' +
              board[i+1] + '|' + board[i+2])
 
def takeinput(board, spaces, turn):
    pos = -1
    print(turn + "'s turn:")
 
    while pos == -1:
        try:
            print("Pick position 1-9:")
            pos = int(input())
            if(pos < 1 or pos > 9):
                pos = -1
            elif board[pos - 1] != ' ':
                pos = -1
        except:
            print("enter a valid position")
    spaces -= 1
    board[pos - 1] = turn
    if turn == 'X':
        turn = 'O'
    else:
        turn = 'X'
    return board, spaces, turn
 
def checkwin(board):
    # could probably make this better
    for i in range(0, 3):
        # rows
        r = i*3
        if board[r] != ' ':
            if board[r] == board[r+1] and board[r+1] == board[r+2]:
                return board[r]
        # columns
        if board[i] != ' ':
            if board[i] == board[i+3] and board[i] == board[i+6]:
                return board[i]
    # diagonals
    if board[0] != ' ':
        if (board[0] == board[4] and board[4] == board[8]):
            return board[0]
    if board[2] != ' ':
        if (board[2] == board[4] and board[4] == board[6]):
            return board[2]
 
    return 0
 
board = [' ']*9
 
while not win and spaces:
    draw(board)
    board, spaces, turn = takeinput(board, spaces, turn)
    win = checkwin(board)
    os.system('cls')
 
draw(board)
 
if not win and not spaces:
    print("draw")
elif win:
    print(f'{win} wins')
    input()




import numpy as np
theta = 1                        
epoch = 3                      
 
class Perceptron(object):
    def __init__(self, input_size, learning_rate=0.2):
        self.learning_rate = learning_rate
        self.weights = np.zeros(input_size + 1) # zero init for weights and bias    
           
    def predict(self, x):
         return (np.dot(x, self.weights[1:]) + self.weights[0]) # X.W + B 
                
    def train(self, x, y, weights):           
        for inputs, label in zip(x, y):
            net_in = self.predict(inputs)
            if net_in > theta:                        
                y_out = 1
            elif net_in < -theta:
                y_out = -1
            else:
                y_out = 0
            if y_out != label: # updating the net on incorrect prediction                    
                self.weights[1:] += self.learning_rate * label * inputs # W = alpha * Y * X
                self.weights[0] += self.learning_rate * label  # B = alpha * Y         
            print(inputs, net_in, label, y_out, self.weights)
 
if __name__ == "__main__":
    x = []                    
    x.append(np.array([1, 1]))  
    x.append(np.array([1, -1]))
    x.append(np.array([-1, 1]))
    x.append(np.array([-1, -1]))
 
    y = np.array([1, -1, -1, -1])          
 
    perceptron = Perceptron(2)           
 
    for i in range(epoch):
        print("Epoch",i)
        print("X1 X2 ", " Net ", " T ", " Y ", " B Weights")    
        weights = perceptron.weights
        print("Initial Weights", weights)
        perceptron.train(x, y, weights)

